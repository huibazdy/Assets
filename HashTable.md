> 键值对

【例】

通讯录：键是人名，值是电话号码。



一个生活中的例子是衣柜中的抽屉，例如你在整理存放衣物的时候，第一格放内衣，第二格放T恤，第三格放袜子。第几格，或者说抽屉索引就是键，与其对应的放置的衣物种类就是值。



小结：键起到索引作用，值是与键对应的数据。这样组织有对应关系的二元组数据，可以通过键来高效查找。



> 哈希表

存储键值对的一种数据结构。



> 为什么要提出哈希表

提高查找效率。

想象一下这种情况：通讯录有十万个联系人条目，我们要找到需要的某个联系人。

是不是需要挨个核对名字，效率很低。这是一种典型的遍历查找方式，时间复杂度最差为`O(n)`。



> 哈希表的查找优化思想

给出一个数据结构，每一个条目分为索引和值。索引是通过键值对的键经过哈希函数计算出来的。最终达到一种理想情况：每一个键值对的键映射完只对应唯一的一个索引。这样就可以直接通过数组索引访问数组中的数据也就是键值对的值。而数组通过索引访问的操作，时间复杂度为`O(1)`，这样就优化了查找效率。



还是回到通讯录的场景，哈希函数为：去每个字母对应的值（a-z 对应 0~25）求和。

例如：

Ada：0+3+0 = 3

Bob：1+14+1 = 16

我们取哈希表的大小为 18。有一种特殊情况是：

Tim：19+8+12=39 > 18，进行取余操作，39 % 18  =  3

这样问题又来了，哈希值与 Ada 相同，这就造成了哈希冲突。



> 哈希冲突

解决哈希冲突的思路：

1. 发现该索引已不空闲，即已存储值，检查下一个索引位置一旦为空就存入。如果找到最后一个位置也不空，跳到第一个索引位置继续找；
2. 设计每个索引对应一个数组或一个链表而不是单一的存储位置，可以存储多个对象，即使哈希值一样也可以将值存储同一个索引下；
3. 增加表的大小，可以大大减小冲突几率。



* 开放定址法

    1. 线性探测法：被占用后，步长为 1 向后寻找
    2. 二次探测法：被占用后，步长为 2 向后寻找
    3. 伪随机探测法：被占用后，随机出一个数组

* 拉链法

    在冲突处维护一个链表，将所有冲突元素放入该链表





> 哈希函数

好的哈希函数可以大大减少冲突概率，在有限表大小（桶多少）情况下，尽可能的让键值对均匀分布在不同表的位置上（不同桶中）

最坏结果：全部放入一个桶中，这样就和数组查找没区别。



> 自己实现哈希表





> C++中哈希表的实现





> 哈希表的使用案例





> 哈希表的思想

哈希表的思想是将无序键值对数据转换为可以一个有序“数组”，这个数组的索引是利用键通过哈希函数计算得到的哈希值；数组元素是键值对中键对应的值。

核心：**从通过遍历键来查找，转化为数组下标访问**。