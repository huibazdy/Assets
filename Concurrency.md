# 并发机制

- [x] 临界区
- [x] 原子性
- [x] 竞争条件
- [x] 同步



> ***为什么要防止共享内存被并发访问？***

因为不同线程并发访问会导致，各线程相互覆盖共享的数据，从而使被访问的数据处于不一致的状态。

并发访问共享数据是造成系统不稳定的一个重要原因，且这种错误很难被跟踪和调试。

所以需要采取强制措施，避免共享数据被并发访问。

【参考资料】《Linux内核设计与实现——原书第3版》



> ***临界区***

用户进程中访问***共享内存***区的程序片段称为临界区。或者说临界区是访问和操作共享数据的代码段。



> ***临界区互斥***

在多个进程都想访问共享内存的时候，会出现临界区互斥。



> ***原子性***

***原子性***不如说是原子地执行，即：操作在执行完成前不可被打断。就如同将整个临界区（代码段）看做是一条不可分割的指令一样。

如果两个执行线程（Thread execution，指任何正在执行的代码实例）可能处于同一个临界区中同时执行，那么这个程序就会包含一个bug。如果这种情况发生了，我们就称之为***竞争条件（race condition）***。顾名思义，这样的情况会引起线程竞争。

竞争引起的错误非常不易重现，故调试该错误会非常困难。避免并发访问共享数据或者说防止竞争条件发生的机制称为***同步（synchronization）***。





> ***CPU进程切换***

单核CPU只有在发生中断时才会进行进程切换。



> ***单核中的临界区互斥***

单核系统中的进程间临界区互斥，借助`local_irq_disable()`与`local_irq_enable()`来控制 CPU 是否支持切换进程，从而达到独占CPU的目的。进入临界区前调用`local_irq_disable()`，离开临界区之后调用`local_irq_enable()`。



> ***多核中的临界区互斥***

多核系统中的进程间临界区互斥，主要是借助**<u>锁</u>**机制。



## 临界区

考虑这样一个现实情况：一个人去ATM机取款，流程应该是以下步骤：

1. 插卡
2. 输密码
3. 选择取款服务
4. 输入金额并确认
5. 取款

模拟代码：

```c
int get_total_from_account();  //定义获取账户余额的函数
int get_withdrawl_amount();    //定义获取取款金额的函数
int update_total_account(int); //定义刷新余额的函数
int spit_out_money(int);       //定义一个吐钱的函数

int rest = get_total_from_account();
int want = get_withdrawl_amount();

if(rest < want){
    error("You do not have that much money!");
    return -1;
}

rest -= want;
update_total_account(total);    //刷新余额
spit_out_money(want);           //吐钱
```

考虑这样一种情况，在另一台ATM机上，你的妻子也在同一个账户取款，会发生什么事？

假设账户余额为2000，你申请的是取1000，你妻子申请的是取1500，一个显然的事实是，你们俩只有一个人能完成取款，因为总和超过了账户余额。

这种情况下就出现了竞争。

显而易见，金融机构要严格保证这种竞争情况不发生。必须在某些操作期间对账户进行锁定，保证这一套操作完成期间不被其他事务打断，也就是相对其他任何事务是原子性的，该事务必须完整地执行完成。要么不发生，发生了就不能被打断，直到执行完。



## 小结

***临界区***出现，多个线程出现临界区重合会引发***竞争条件***，这里引入***原子性***概念，为了使临界区代码的原子性执行，所以引入***同步***来保证原子性。





## 锁

对一些简单共享数据操作，可以采用原子指令的方式。但是对共享数据是一种复杂数据结构（例如队列）时，竞争条件会使数据结构被破坏。

锁机制应运而生。



> ***被锁住的是什么？***

是某个线程（人）的临界区（做一个任务）。



> ***上锁后的效果是什么？***

为执行临界区（做一个任务）的线程（人）开了一个上锁的房间，保证做事的时候不被打扰。在线程执行完临界区，才会打开房间，归还锁。

房间可以理解为一种不被打扰的状态，这种状态依赖于持有一把锁来实现。



> ***锁机制的实现***

1. 申请锁
2. 上锁
3. 线程执行临界区代码段
4. 开锁
5. 归还锁



> ***小结***

线程持有锁，而锁保护了共享数据。从谁手里保护了数据？一种危险情况：多个线程同时访问共享数据。怎样保护的？保证一个时间段内只有一个线程访问共享数据。



> ***注意***

使用锁机制是程序员自己的编程手段，而不是强制性的、非自愿的。



## Linux锁机制

Linux提供了多种锁机制，它们的区别主要在于：当锁被其他线程持有，不可用时的行为表现。

例如：某些锁被争用时会简单地执行***忙等待***（一个不断检查锁状态的循环，知道锁变为可用）；而一些锁会使当前任务睡眠直到锁可用为止。

现在看来，锁看似解决了竞争条件，但是引入了新的竞争，也就是锁的竞争。

其实不是，根因在于：临界区不能保证原子性操作，但锁可以保证原子性操作。
